import { ValueValidator } from '../ValueValidator';
export declare class ArrayValueValidatorBuilder<TModel, TPropertyName extends keyof TModel, TValue extends Array<TEachValue> & TModel[TPropertyName], TEachValue> {
    private eachValueValidatorBuilder;
    constructor(rebuildValidate: () => void);
    build: () => ValueValidator<TModel, TValue>;
    getAllRules: () => {
        notEqual: (forbiddenValue: TValue[0] & TEachValue) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        equal: (requiredValue: TValue[0] & TEachValue) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notNull: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        null: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEmpty: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        length: (minLength: number, maxLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        maxLength: (maxLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        minLength: (minLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        matches: (pattern: RegExp) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        emailAddress: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        exclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        inclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        scalePrecision: (precision: number, scale: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
                equal: (requiredValue: TValue[0] & TEachValue) => any;
                must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
                scalePrecision: any;
            };
            when: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TValue) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue[0] & TEachValue) => any;
            equal: (requiredValue: TValue[0] & TEachValue) => any;
            must: (predicate: (value: TValue[0] & TEachValue, model: TValue) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => import("../IValidator").IValidator<TValue[0] & TEachValue>) => any;
            scalePrecision: any;
        };
    };
}
