import { IValidator } from '../IValidator';
import { ValueValidator } from '../ValueValidator';
export declare class ValueValidatorBuilder<TModel, TPropertyName extends keyof TModel, TValue extends TModel[TPropertyName]> {
    private rules;
    private rebuildValidate;
    constructor(rebuildValidate: () => void);
    build: () => ValueValidator<TModel, TValue>;
    private pushRule;
    withMessage: (message: string) => {
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            equal: (requiredValue: TValue) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            must: (predicate: (value: TValue, model: TModel) => boolean) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notNull: () => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            null: () => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEmpty: () => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            length: (minLength: number, maxLength: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            maxLength: (maxLength: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            minLength: (minLength: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            matches: (pattern: RegExp) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            emailAddress: () => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            lessThan: (threshold: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            lessThanOrEqualTo: (threshold: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            greaterThan: (threshold: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            greaterThanOrEqualTo: (threshold: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            exclusiveBetween: (lowerBound: number, upperBound: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            inclusiveBetween: (lowerBound: number, upperBound: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            setValidator: (validatorProducer: () => IValidator<TValue>) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            scalePrecision: (precision: number, scale: number) => {
                withMessage: any;
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            equal: (requiredValue: TValue) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            must: (predicate: (value: TValue, model: TModel) => boolean) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notNull: () => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            null: () => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEmpty: () => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            length: (minLength: number, maxLength: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            maxLength: (maxLength: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            minLength: (minLength: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            matches: (pattern: RegExp) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            emailAddress: () => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            lessThan: (threshold: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            lessThanOrEqualTo: (threshold: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            greaterThan: (threshold: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            greaterThanOrEqualTo: (threshold: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            exclusiveBetween: (lowerBound: number, upperBound: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            inclusiveBetween: (lowerBound: number, upperBound: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            setValidator: (validatorProducer: () => IValidator<TValue>) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            scalePrecision: (precision: number, scale: number) => {
                withMessage: any;
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
        };
        notEqual: (forbiddenValue: TValue) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        equal: (requiredValue: TValue) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        must: (predicate: (value: TValue, model: TModel) => boolean) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notNull: () => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        null: () => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEmpty: () => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        length: (minLength: number, maxLength: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        maxLength: (maxLength: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        minLength: (minLength: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        matches: (pattern: RegExp) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        emailAddress: () => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThan: (threshold: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThanOrEqualTo: (threshold: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThan: (threshold: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThanOrEqualTo: (threshold: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        exclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        inclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        setValidator: (validatorProducer: () => IValidator<TValue>) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        scalePrecision: (precision: number, scale: number) => {
            withMessage: any;
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: any;
        };
    };
    when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
        notEqual: (forbiddenValue: TValue) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        equal: (requiredValue: TValue) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        must: (predicate: (value: TValue, model: TModel) => boolean) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notNull: () => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        null: () => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEmpty: () => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        length: (minLength: number, maxLength: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        maxLength: (maxLength: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        minLength: (minLength: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        matches: (pattern: RegExp) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        emailAddress: () => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        exclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        inclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        setValidator: (validatorProducer: () => IValidator<TValue>) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        scalePrecision: (precision: number, scale: number) => {
            withMessage: (message: string) => {
                when: any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
            when: any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: any;
        };
    };
    unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
        notEqual: (forbiddenValue: TValue) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        equal: (requiredValue: TValue) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        must: (predicate: (value: TValue, model: TModel) => boolean) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notNull: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        null: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEmpty: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        length: (minLength: number, maxLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        maxLength: (maxLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        minLength: (minLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        matches: (pattern: RegExp) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        emailAddress: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        exclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        inclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        setValidator: (validatorProducer: () => IValidator<TValue>) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        scalePrecision: (precision: number, scale: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: any;
        };
    };
    notEqual: (forbiddenValue: TValue) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    equal: (requiredValue: TValue) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    must: (predicate: (value: TValue, model: TModel) => boolean) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    notNull: () => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    null: () => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    notEmpty: () => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    length: (minLength: number, maxLength: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    maxLength: (maxLength: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    minLength: (minLength: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    matches: (pattern: RegExp) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    emailAddress: () => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    lessThan: (threshold: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    lessThanOrEqualTo: (threshold: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    greaterThan: (threshold: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    greaterThanOrEqualTo: (threshold: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    exclusiveBetween: (lowerBound: number, upperBound: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    inclusiveBetween: (lowerBound: number, upperBound: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    setValidator: (validatorProducer: () => IValidator<TValue>) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    scalePrecision: (precision: number, scale: number) => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: any;
    };
    getAllRules: () => {
        notEqual: (forbiddenValue: TValue) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        equal: (requiredValue: TValue) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        must: (predicate: (value: TValue, model: TModel) => boolean) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notNull: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        null: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEmpty: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        length: (minLength: number, maxLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        maxLength: (maxLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        minLength: (minLength: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        matches: (pattern: RegExp) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        emailAddress: () => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        lessThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThan: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        greaterThanOrEqualTo: (threshold: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        exclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        inclusiveBetween: (lowerBound: number, upperBound: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        setValidator: (validatorProducer: () => IValidator<TValue>) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        scalePrecision: (precision: number, scale: number) => {
            withMessage: (message: string) => {
                when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: any;
            };
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => any;
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: any;
        };
    };
    getAllRulesAndExtensions: () => {
        withMessage: (message: string) => {
            when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
                notEqual: (forbiddenValue: TValue) => any;
                equal: (requiredValue: TValue) => any;
                must: (predicate: (value: TValue, model: TModel) => boolean) => any;
                notNull: () => any;
                null: () => any;
                notEmpty: () => any;
                length: (minLength: number, maxLength: number) => any;
                maxLength: (maxLength: number) => any;
                minLength: (minLength: number) => any;
                matches: (pattern: RegExp) => any;
                emailAddress: () => any;
                lessThan: (threshold: number) => any;
                lessThanOrEqualTo: (threshold: number) => any;
                greaterThan: (threshold: number) => any;
                greaterThanOrEqualTo: (threshold: number) => any;
                exclusiveBetween: (lowerBound: number, upperBound: number) => any;
                inclusiveBetween: (lowerBound: number, upperBound: number) => any;
                setValidator: (validatorProducer: () => IValidator<TValue>) => any;
                scalePrecision: (precision: number, scale: number) => any;
            };
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        when: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        unless: (condition: (model: TModel) => boolean, appliesTo?: "AppliesToAllValidators" | "AppliesToCurrentValidator") => {
            notEqual: (forbiddenValue: TValue) => any;
            equal: (requiredValue: TValue) => any;
            must: (predicate: (value: TValue, model: TModel) => boolean) => any;
            notNull: () => any;
            null: () => any;
            notEmpty: () => any;
            length: (minLength: number, maxLength: number) => any;
            maxLength: (maxLength: number) => any;
            minLength: (minLength: number) => any;
            matches: (pattern: RegExp) => any;
            emailAddress: () => any;
            lessThan: (threshold: number) => any;
            lessThanOrEqualTo: (threshold: number) => any;
            greaterThan: (threshold: number) => any;
            greaterThanOrEqualTo: (threshold: number) => any;
            exclusiveBetween: (lowerBound: number, upperBound: number) => any;
            inclusiveBetween: (lowerBound: number, upperBound: number) => any;
            setValidator: (validatorProducer: () => IValidator<TValue>) => any;
            scalePrecision: (precision: number, scale: number) => any;
        };
        notEqual: (forbiddenValue: TValue) => any;
        equal: (requiredValue: TValue) => any;
        must: (predicate: (value: TValue, model: TModel) => boolean) => any;
        notNull: () => any;
        null: () => any;
        notEmpty: () => any;
        length: (minLength: number, maxLength: number) => any;
        maxLength: (maxLength: number) => any;
        minLength: (minLength: number) => any;
        matches: (pattern: RegExp) => any;
        emailAddress: () => any;
        lessThan: (threshold: number) => any;
        lessThanOrEqualTo: (threshold: number) => any;
        greaterThan: (threshold: number) => any;
        greaterThanOrEqualTo: (threshold: number) => any;
        exclusiveBetween: (lowerBound: number, upperBound: number) => any;
        inclusiveBetween: (lowerBound: number, upperBound: number) => any;
        setValidator: (validatorProducer: () => IValidator<TValue>) => any;
        scalePrecision: (precision: number, scale: number) => any;
    };
    private getLatestRule;
}
